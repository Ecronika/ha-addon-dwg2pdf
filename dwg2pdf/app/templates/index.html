<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DXF zu PDF Konverter</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f4f4f9;
        }

        .container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }

        #viewer-container {
            flex: 3;
            height: 600px;
            background: #fff;
            border: 1px solid #ccc;
        }

        #sidebar {
            flex: 1;
            background: #fff;
            padding: 15px;
            border: 1px solid #ccc;
            max-height: 600px;
            overflow-y: auto;
        }

        .layer-item {
            margin-bottom: 8px;
        }

        button {
            padding: 10px 15px;
            background: #03a9f4;
            color: white;
            border: none;
            cursor: pointer;
        }

        button:hover {
            background: #0288d1;
        }
    </style>
</head>

<body>

    <h1>DXF zu PDF Konverter</h1>

    <div>
        <input type="file" id="dwg-upload" name="file" accept=".dxf">
        <button onclick="uploadFile()">1. DXF Hochladen & Anzeigen</button>
        <br>
        <small style="color:#666; margin-top:5px; display:block;">ℹ️ Bitte <b>ASCII DXF</b> verwenden (kein 'Binary').
            Empfohlen: AutoCAD 2013 oder 2018 ASCII DXF.</small>
    </div>

    <div class="container">
        <div id="viewer-container">
            <p style="text-align:center; margin-top: 250px; color: #888;">Viewer-Vorschau (Wartet auf Datei...)</p>
        </div>

        <div id="sidebar">
            <h3>Ebenen (Layers)</h3>
            <div id="layer-list">
                <p>Noch keine Ebenen geladen.</p>
            </div>
            <hr>
            <h3>Maßstab & Einheit</h3>
            <div style="margin-bottom: 10px;">
                <label for="dxf-unit" style="display:inline-block; width: 80px;">Einheit:</label>
                <select id="dxf-unit" style="width: 140px;">
                    <option value="1000">Meter (m)</option>
                    <option value="10" selected>Zentimeter (cm)</option>
                    <option value="1">Millimeter (mm)</option>
                </select>
            </div>
            <div style="margin-bottom: 15px;">
                <label for="pdf-scale" style="display:inline-block; width: 80px;">Maßstab 1:</label>
                <input type="number" id="pdf-scale" value="100" style="width: 132px;" min="1">
            </div>
            <button onclick="requestPDF()" id="btn-pdf" style="display:none; width: 100%;">2. PDF Erstellen</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dxf-parser@1.1.2/dist/dxf-parser.js"></script>
    <script src="static/three-dxf.js"></script>

    <script>
        let currentDxfFile = "";
        let currentOriginalName = "";
        let viewer = null;

        async function uploadFile() {
            const fileInput = document.getElementById('dwg-upload');
            if (fileInput.files.length === 0) return alert("Bitte Datei wählen.");

            const formData = new FormData();
            formData.append("file", fileInput.files[0]);

            const container = document.getElementById('viewer-container');
            container.innerHTML = "<p style='text-align:center; margin-top: 250px;'>Lade DXF hoch... Bitte warten.</p>";

            // Wichtig: Dem Browser Zeit geben, die Upload-Nachricht zu zeichnen
            await new Promise(resolve => setTimeout(resolve, 50));

            try {
                const response = await fetch('upload', { method: 'POST', body: formData });
                const data = await response.json();

                if (data.success) {
                    currentDxfFile = data.dxf_file;
                    currentOriginalName = data.original_name;
                    await loadAndRenderDXF(currentDxfFile);
                } else {
                    alert("Fehler: " + data.error);
                    container.innerHTML = "<p>Fehler beim Upload: " + data.error + "</p>";
                }
            } catch (err) {
                console.error("Upload Error:", err);
                container.innerHTML = "<p style='color:red;'>Verbindungsfehler beim Upload.</p>";
            }
        }

        async function loadAndRenderDXF(filename) {
            const container = document.getElementById('viewer-container');
            container.innerHTML = "<p style='text-align:center; margin-top: 250px;'>1/3: Lade DXF-Datei vom Server herunter...</p>";

            try {
                // Kurz warten, damit "1/3" gezeichnet wird
                await new Promise(resolve => setTimeout(resolve, 50));
                console.log("Hole DXF vom Server:", filename);

                const response = await fetch('dxf/' + filename);
                if (!response.ok) throw new Error("DXF konnte nicht geladen werden (Status " + response.status + ")");

                const dxfText = await response.text();
                console.log("DXF geladen, Größe:", dxfText.length, "Bytes");

                // 2. DXF parsen
                container.innerHTML = "<p style='text-align:center; margin-top: 250px;'>2/3: Analysiere DXF-Struktur (Browser rechnet, bitte warten)...</p>";

                // Wir geben dem Browser einen winzigen Moment zum Zeichnen des obigen Textes
                await new Promise(resolve => setTimeout(resolve, 50));

                console.log("Starte DXF Parser...");
                const parser = new window.DxfParser();
                const dxf = parser.parseSync(dxfText);
                console.log("DXF geparst:", dxf);

                // 3. Font laden und Plan rendern
                container.innerHTML = "<p style='text-align:center; margin-top: 250px;'>3/3: Lade Schriften und zeichne Plan...</p>";
                await new Promise(resolve => setTimeout(resolve, 50));

                window.originalDxfEntities = [...dxf.entities];
                window.currentDxfObject = dxf;

                container.innerHTML = ""; // Text weg
                console.log("Initialisiere ThreeDxf Viewer...");

                // Pass local TTF font to Troika to prevent external CORS/Ingress issues
                viewer = new window.ThreeDxf.Viewer(dxf, container, container.clientWidth, container.clientHeight, 'static/fonts/Roboto-Regular.ttf');

                // 4. Layer-Liste bauen
                buildLayerSidebar(dxf.tables.layer.layers);
                document.getElementById('btn-pdf').style.display = 'block';

                // 5. Ansicht passend skalieren
                fitCameraToSelection(viewer);
                console.log("Fertig gerendert!");

            } catch (error) {
                console.error("Fehler beim Rendern:", error);

                // Zeige den genauen Fehler auf dem Bildschirm
                container.innerHTML = "<p style='text-align:center; margin-top: 220px; color:red;'>" +
                    "<b>Fehler bei der Anzeige der Vorschau.</b><br><br>" +
                    error.message + "<br><br>" +
                    "Die DXF ist evtl. zu groß, nutzt nicht unterstützte Features oder ist keine ASCII-DXF." +
                    "</p>";
            }
        }

        function fitCameraToSelection(viewer) {
            if (!viewer || !viewer.scene || !viewer.camera || !viewer.controls) return;

            const box = new THREE.Box3();
            viewer.scene.updateMatrixWorld(true);

            viewer.scene.traverse(child => {
                if ((child.isMesh || child.isLine || child.isPoints) && child.visible) {
                    // Check if parent hierarchy is also visible
                    let isVisible = true;
                    let obj = child;
                    while (obj) {
                        if (!obj.visible) {
                            isVisible = false;
                            break;
                        }
                        obj = obj.parent;
                    }
                    if (isVisible) {
                        if (!child.geometry.boundingBox) {
                            child.geometry.computeBoundingBox();
                        }
                        const childBox = child.geometry.boundingBox.clone();
                        // Prevent empty/infinity boxes from corrupting the master box union
                        if (!childBox.isEmpty() && isFinite(childBox.min.x) && isFinite(childBox.max.x)) {
                            childBox.applyMatrix4(child.matrixWorld);
                            box.union(childBox);
                        }
                    }
                }
            });

            if (box.isEmpty() || !isFinite(box.min.x)) return;

            const width = box.max.x - box.min.x;
            const height = box.max.y - box.min.y;
            const centerX = box.min.x + width / 2;
            const centerY = box.min.y + height / 2;

            const container = document.getElementById('viewer-container');
            let containerAspect = container.clientWidth / container.clientHeight;
            if (isNaN(containerAspect) || containerAspect <= 0) containerAspect = 1;

            let newWidth = width;
            let newHeight = height;

            if (width / height > containerAspect) {
                newHeight = width / containerAspect;
            } else {
                newWidth = height * containerAspect;
            }

            // Add padding (1.05x) so it's not flush to the edges
            newWidth *= 1.05;
            newHeight *= 1.05;

            // Make sure width/height are not zero and are valid numbers
            if (!isFinite(newWidth) || !isFinite(newHeight) || newWidth < 0.001 || newHeight < 0.001) {
                newWidth = 10;
                newHeight = 10 / containerAspect;
            }

            viewer.camera.left = -newWidth / 2;
            viewer.camera.right = newWidth / 2;
            viewer.camera.top = newHeight / 2;
            viewer.camera.bottom = -newHeight / 2;

            // To prevent orthographic camera from zooming strangely,
            // we must ensure the zoom is exactly 1 before updating the projection.
            viewer.camera.zoom = 1;

            viewer.camera.position.x = centerX;
            viewer.camera.position.y = centerY;
            viewer.camera.updateProjectionMatrix();

            // Also reset controls internal zoom state if needed (which orbits do)
            if (viewer.controls.reset) viewer.controls.reset();

            viewer.controls.target.set(centerX, centerY, 0);
            viewer.camera.position.set(centerX, centerY, 10);
            viewer.controls.update();

            if (viewer.render) viewer.render();
        }

        function buildLayerSidebar(layers) {
            const layerListDiv = document.getElementById('layer-list');
            layerListDiv.innerHTML = ""; // Leeren

            // Durch alle gefundenen Layer iterieren
            for (const [layerName, layerData] of Object.entries(layers)) {
                const div = document.createElement('div');
                div.className = 'layer-item';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'layer-checkbox';
                checkbox.value = layerName;
                checkbox.checked = true; // Standardmäßig sind alle Layer an
                checkbox.id = 'layer-' + layerName;

                // Live-Vorschau: Blendet Three.js Objekte anhand des Layer-Namens ein/aus
                checkbox.addEventListener('change', (e) => {
                    const scene = viewer.scene;
                    const isVisible = e.target.checked;

                    if (scene) {
                        // Traverse geht rekursiv durch alle Untergruppen und Blöcke im 3D-Modell
                        scene.traverse(child => {
                            if (child.userData && child.userData.layer === layerName) {
                                child.visible = isVisible;
                            }
                        });
                        // Neu zeichnen ohne die Ansicht zurückzusetzen
                        if (viewer.render) viewer.render();
                    }
                });

                const label = document.createElement('label');
                label.htmlFor = 'layer-' + layerName;
                label.innerText = " " + layerName;

                div.appendChild(checkbox);
                div.appendChild(label);
                layerListDiv.appendChild(div);
            }
        }

        async function requestPDF() {
            const btn = document.getElementById('btn-pdf');
            btn.disabled = true;
            const originalText = btn.innerText;
            btn.innerText = "Erstelle PDF... (Bitte warten)";

            // Sammelt alle AKTIVEN Checkboxen aus der Sidebar
            const checkboxes = document.querySelectorAll('.layer-checkbox:checked');
            const activeLayers = Array.from(checkboxes).map(cb => cb.value);

            // Werte für Maßstab und Einheit holen
            const unitMultiplier = parseFloat(document.getElementById('dxf-unit').value);
            const scaleDenominator = parseFloat(document.getElementById('pdf-scale').value);

            try {
                const response = await fetch('generate_pdf', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        dxf_file: currentDxfFile,
                        original_name: currentOriginalName,
                        layers: activeLayers,
                        unit: unitMultiplier,
                        scale: scaleDenominator
                    })
                });

                if (response.ok) {
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;

                    // Hole Dateiname aus Response Header, falls vorhanden
                    const contentDisposition = response.headers.get('Content-Disposition');
                    let downloadName = currentOriginalName.replace('.dxf', '.pdf'); // Fallback
                    if (contentDisposition && contentDisposition.includes('filename=')) {
                        const match = contentDisposition.match(/filename="?([^"]+)"?/);
                        if (match) downloadName = match[1];
                    }

                    a.download = downloadName;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    window.URL.revokeObjectURL(url);
                } else {
                    let errorMsg = response.statusText;
                    try { const errData = await response.json(); errorMsg = errData.error || errorMsg; } catch (e) { }
                    alert("Fehler bei der PDF-Erstellung: " + errorMsg);
                }
            } catch (e) {
                alert("Netzwerkfehler oder Server nicht erreichbar.");
            } finally {
                btn.innerText = originalText;
                btn.disabled = false;
            }
        }
    </script>
</body>

</html>