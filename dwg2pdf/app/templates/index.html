<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DXF zu PDF Konverter</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f4f4f9;
        }

        .container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }

        #viewer-container {
            flex: 3;
            height: calc(100vh - 150px);
            background: #fff;
            border: 1px solid #ccc;
        }

        #sidebar {
            flex: 1;
            background: #fff;
            padding: 15px;
            border: 1px solid #ccc;
            max-height: calc(100vh - 150px);
            overflow-y: auto;
        }

        #toast-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
        }

        .toast {
            background: #f44336;
            color: white;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 4px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            opacity: 1;
            transition: opacity 0.5s;
        }

        .toast.success {
            background: #4CAF50;
        }

        .toast.info {
            background: #2196F3;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #03a9f4;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .layer-item {
            margin-bottom: 8px;
        }

        button {
            padding: 10px 15px;
            background: #03a9f4;
            color: white;
            border: none;
            cursor: pointer;
        }

        button:hover {
            background: #0288d1;
        }
    </style>
</head>

<body>

    <div id="toast-container"></div>
    <h1>DXF zu PDF Konverter</h1>

    <div>
        <input type="file" id="dwg-upload" name="file" accept=".dwg, .dxf">
        <button onclick="uploadFile()">1. DWG Laden & Vorschau</button>
        <br>
        <small style="color:#666; margin-top:5px; display:block;">ℹ️ DWG & DXF Uploads unterstützt. Es wird automatisch
            eine ASCII DXF konvertiert.<br>
            ⚠️ <b>Hinweis:</b> Proxy-Objekte aus CAD-Aufsätzen (Architektur/Civil3D) werden in grundlegende
            Linien/Blöcke abstrahiert und verlieren ihre native Intelligenz.</small>
    </div>

    <div class="container">
        <div id="viewer-container">
            <p style="text-align:center; margin-top: 250px; color: #888;">Viewer-Vorschau (Wartet auf Datei...)</p>
        </div>

        <div id="sidebar">
            <h3>Ebenen (Layers)</h3>
            <div id="layer-list">
                <p>Noch keine Ebenen geladen.</p>
            </div>
            <hr>
            <h3>Maßstab & Einheit</h3>
            <div style="margin-bottom: 10px;">
                <label for="dxf-unit" style="display:inline-block; width: 80px;">Einheit:</label>
                <select id="dxf-unit" style="width: 140px;">
                    <option value="1000">Meter (m)</option>
                    <option value="10" selected>Zentimeter (cm)</option>
                    <option value="1">Millimeter (mm)</option>
                </select>
            </div>
            <div style="margin-bottom: 15px;">
                <label for="pdf-scale" style="display:inline-block; width: 80px;">Maßstab 1:</label>
                <input type="number" id="pdf-scale" value="100" style="width: 132px;" min="1">
            </div>
            <button onclick="requestPDF()" id="btn-pdf" style="display:none; width: 100%; margin-bottom: 10px;">2. PDF
                Erstellen</button>
            <button onclick="downloadDXF()" id="btn-dxf" style="display:none; width: 100%; background: #4CAF50;">3. DXF
                Herunterladen</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dxf-parser@1.1.2/dist/dxf-parser.js"></script>
    <script src="static/three-dxf.js"></script>

    <script>
        let currentDxfFile = "";
        let currentOriginalName = "";
        let viewer = null;

        function showToast(message, type = 'error') {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = 'toast ' + type;
            toast.innerText = message;
            container.appendChild(toast);
            setTimeout(() => {
                toast.style.opacity = '0';
                setTimeout(() => toast.remove(), 500);
            }, 5000);
        }

        async function uploadFile() {
            const fileInput = document.getElementById('dwg-upload');
            if (fileInput.files.length === 0) return showToast("Bitte Datei wählen.");

            const formData = new FormData();
            formData.append("file", fileInput.files[0]);

            const container = document.getElementById('viewer-container');
            container.innerHTML = "<div style='text-align:center; margin-top: 200px;'><div class='spinner'></div><p>Lade & Konvertiere DWG... Bitte warten.</p></div>";

            // Wichtig: Dem Browser Zeit geben, die Upload-Nachricht zu zeichnen
            await new Promise(resolve => setTimeout(resolve, 50));

            try {
                const response = await fetch('upload', { method: 'POST', body: formData });
                const data = await response.json();

                if (data.success) {
                    currentDxfFile = data.dxf_file;
                    currentOriginalName = data.original_name;
                    showToast("Upload erfolgreich", "success");
                    await loadAndRenderDXF(currentDxfFile);
                } else {
                    showToast("Fehler: " + data.error);
                    container.innerHTML = "<p style='text-align:center; margin-top:200px;'>Fehler beim Upload: " + data.error + "</p>";
                }
            } catch (err) {
                console.error("Upload Error:", err);
                showToast("Verbindungsfehler beim Upload.");
                container.innerHTML = "<p style='text-align:center; margin-top:200px; color:red;'>Verbindungsfehler beim Upload.</p>";
            }
        }

        async function loadAndRenderDXF(filename) {
            const container = document.getElementById('viewer-container');
            container.innerHTML = "<div style='text-align:center; margin-top: 200px;'><div class='spinner'></div><p>1/3: Lade DXF-Datei vom Server herunter...</p></div>";

            try {
                // Kurz warten, damit "1/3" gezeichnet wird
                await new Promise(resolve => setTimeout(resolve, 50));
                console.log("Hole DXF vom Server:", filename);

                const response = await fetch('dxf/' + filename);
                if (!response.ok) throw new Error("DXF konnte nicht geladen werden (Status " + response.status + ")");

                const dxfText = await response.text();
                console.log("DXF geladen, Größe:", dxfText.length, "Bytes");

                // 2. DXF parsen
                container.innerHTML = "<div style='text-align:center; margin-top: 200px;'><div class='spinner'></div><p>2/3: Analysiere DXF-Struktur (Browser rechnet, bitte warten)...</p></div>";

                console.log("Starte DXF Parser via WebWorker...");
                const workerCode = `
                    importScripts('https://cdn.jsdelivr.net/npm/dxf-parser@1.1.2/dist/dxf-parser.js');
                    self.onmessage = function(e) {
                        try {
                            const parser = new DxfParser();
                            const dxf = parser.parseSync(e.data);
                            postMessage({ success: true, dxf: dxf });
                        } catch(err) {
                            postMessage({ success: false, error: err.message || err });
                        }
                    };
                `;
                const blob = new Blob([workerCode], { type: 'application/javascript' });
                const worker = new Worker(URL.createObjectURL(blob));

                const dxf = await new Promise((resolve, reject) => {
                    worker.onmessage = e => {
                        if (e.data.success) resolve(e.data.dxf);
                        else reject(new Error(e.data.error));
                        worker.terminate();
                    };
                    worker.onerror = err => {
                        reject(err);
                        worker.terminate();
                    };
                    worker.postMessage(dxfText);
                });

                console.log("DXF geparst:", dxf);

                // 3. Font laden und Plan rendern
                container.innerHTML = "<div style='text-align:center; margin-top: 200px;'><div class='spinner'></div><p>3/3: Lade Schriften und zeichne Plan...</p></div>";
                await new Promise(resolve => setTimeout(resolve, 50));

                window.originalDxfEntities = [...dxf.entities];
                window.currentDxfObject = dxf;

                container.innerHTML = ""; // Text weg
                console.log("Initialisiere ThreeDxf Viewer...");

                // Pass local TTF font to Troika to prevent external CORS/Ingress issues
                viewer = new window.ThreeDxf.Viewer(dxf, container, container.clientWidth, container.clientHeight, 'static/fonts/Roboto-Regular.ttf');

                // 4. Layer-Liste bauen
                buildLayerSidebar(dxf.tables.layer.layers);
                document.getElementById('btn-pdf').style.display = 'block';
                document.getElementById('btn-dxf').style.display = 'block';

                // 5. Ansicht passend skalieren (mit leichtem Delay, da Text-Geometrien asynchron laden)
                setTimeout(() => {
                    fitCameraToSelection(viewer);
                    console.log("Kamera an Geometrie angepasst!");

                    // Force an additional render pass slightly later to ensure asynchronous TroikaText is drawn
                    setTimeout(() => {
                        if (viewer && viewer.render) viewer.render();
                    }, 300);
                }, 250);

                console.log("Fertig gerendert!");

            } catch (error) {
                console.error("Fehler beim Rendern:", error);

                // Zeige den genauen Fehler auf dem Bildschirm
                container.innerHTML = "<p style='text-align:center; margin-top: 220px; color:red;'>" +
                    "<b>Fehler bei der Anzeige der Vorschau.</b><br><br>" +
                    error.message + "<br><br>" +
                    "Die DXF ist evtl. zu groß, nutzt nicht unterstützte Features oder ist keine ASCII-DXF." +
                    "</p>";
            }
        }

        function fitCameraToSelection(viewer) {
            if (!viewer || !viewer.scene || !viewer.camera || !viewer.controls) return;

            const box = new THREE.Box3();
            viewer.scene.updateMatrixWorld(true);

            viewer.scene.traverse(child => {
                if ((child.isMesh || child.isLine || child.isPoints) && child.visible) {
                    // Check if parent hierarchy is also visible
                    let isVisible = true;
                    let obj = child;
                    while (obj) {
                        if (!obj.visible) {
                            isVisible = false;
                            break;
                        }
                        obj = obj.parent;
                    }
                    if (isVisible) {
                        if (!child.geometry.boundingBox) {
                            child.geometry.computeBoundingBox();
                        }
                        const childBox = child.geometry.boundingBox.clone();

                        // SKIP TEXT ENTITIES: Asynchronous TroikaText geometries or DXF MTEXTs with trailing spaces
                        // often report infinite or massive bounding boxes, ruining the camera framing.
                        let isText = false;
                        if (child.text !== undefined || child.isText) isText = true;
                        if (child.userData && child.userData.entity) {
                            const type = child.userData.entity.type;
                            if (type === 'TEXT' || type === 'MTEXT') isText = true;
                        }

                        // Prevent empty/infinity/text boxes from corrupting the master box union
                        if (!isText && !childBox.isEmpty() && isFinite(childBox.min.x) && isFinite(childBox.max.x)) {
                            // Only include if it has a non-zero area (lines have volume, but rogue empty points don't)
                            // Also ignore absurdly large bounding boxes that represent parsing anomalies
                            const childW = childBox.max.x - childBox.min.x;
                            const childH = childBox.max.y - childBox.min.y;
                            if ((childW > 0.0001 || childH > 0.0001) && childW < 10000000 && childH < 10000000) {
                                childBox.applyMatrix4(child.matrixWorld);
                                box.union(childBox);
                            }
                        }
                    }
                }
            });

            if (box.isEmpty() || !isFinite(box.min.x)) return;

            const width = box.max.x - box.min.x;
            const height = box.max.y - box.min.y;
            const centerX = box.min.x + width / 2;
            const centerY = box.min.y + height / 2;

            console.log(`[AutoFit] Calculated Master Box: min(${box.min.x.toFixed(2)}, ${box.min.y.toFixed(2)}) max(${box.max.x.toFixed(2)}, ${box.max.y.toFixed(2)})`);
            console.log(`[AutoFit] Width: ${width.toFixed(2)}, Height: ${height.toFixed(2)}, Center: (${centerX.toFixed(2)}, ${centerY.toFixed(2)})`);

            const container = document.getElementById('viewer-container');
            let containerAspect = container.clientWidth / container.clientHeight;
            if (isNaN(containerAspect) || containerAspect <= 0) containerAspect = 1;

            let newWidth = width;
            let newHeight = height;

            if (width / height > containerAspect) {
                // The drawing is wider than the screen aspect ratio
                newHeight = width / containerAspect;
            } else {
                // The drawing is taller than the screen aspect ratio
                newWidth = height * containerAspect;
            }

            // Add padding (1.05x) so it's not flush to the edges
            newWidth *= 1.05;
            newHeight *= 1.05;
            console.log(`[AutoFit] Camera aspect matched dimensions: Width: ${newWidth.toFixed(2)}, Height: ${newHeight.toFixed(2)}`);

            // Make sure width/height are not zero and are valid numbers
            if (!isFinite(newWidth) || !isFinite(newHeight) || newWidth < 0.001 || newHeight < 0.001) {
                newWidth = 10;
                newHeight = 10 / containerAspect;
            }

            // Fix Z-Fighting / Precision issues by pulling the whole scene to the origin
            viewer.scene.position.set(-centerX, -centerY, 0);
            viewer.scene.updateMatrixWorld(true);

            viewer.camera.left = -newWidth / 2;
            viewer.camera.right = newWidth / 2;
            viewer.camera.top = newHeight / 2;
            viewer.camera.bottom = -newHeight / 2;

            // To prevent orthographic camera from zooming strangely,
            // we must ensure the zoom is exactly 1 before updating the projection.
            viewer.camera.zoom = 1;

            viewer.camera.position.x = 0;
            viewer.camera.position.y = 0;
            viewer.camera.updateProjectionMatrix();

            // Also reset controls internal zoom state if needed (which orbits do)
            if (viewer.controls.reset) viewer.controls.reset();

            viewer.controls.target.set(0, 0, 0);
            viewer.camera.position.set(0, 0, 10);
            viewer.controls.update();

            if (viewer.render) viewer.render();
        }

        function buildLayerSidebar(layers) {
            const layerListDiv = document.getElementById('layer-list');
            layerListDiv.innerHTML = ""; // Leeren

            // Durch alle gefundenen Layer iterieren
            for (const [layerName, layerData] of Object.entries(layers)) {
                const div = document.createElement('div');
                div.className = 'layer-item';

                // DXF Layer Visibility prüfen (frozen / visible flags vom dxf-parser)
                let isLayerVisible = true;
                if (layerData.visible === false) isLayerVisible = false;
                if (layerData.frozen === true) isLayerVisible = false;

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'layer-checkbox';
                checkbox.value = layerName;
                checkbox.checked = isLayerVisible;
                checkbox.id = 'layer-' + layerName;

                // Initial den Three.js Objekten auch die Sichtbarkeit zuweisen
                if (!isLayerVisible && viewer && viewer.scene) {
                    viewer.scene.traverse(child => {
                        if (child.userData && child.userData.layer === layerName) {
                            child.visible = false;
                        }
                    });
                }

                // Live-Vorschau: Blendet Three.js Objekte anhand des Layer-Namens ein/aus
                checkbox.addEventListener('change', (e) => {
                    const scene = viewer.scene;
                    const isVisible = e.target.checked;

                    if (scene) {
                        // Traverse geht rekursiv durch alle Untergruppen und Blöcke im 3D-Modell
                        scene.traverse(child => {
                            if (child.userData && child.userData.layer === layerName) {
                                child.visible = isVisible;
                            }
                        });
                        // Neu zeichnen ohne die Ansicht zurückzusetzen
                        if (viewer.render) viewer.render();
                    }
                });

                const label = document.createElement('label');
                label.htmlFor = 'layer-' + layerName;
                label.innerText = " " + layerName;

                div.appendChild(checkbox);
                div.appendChild(label);
                layerListDiv.appendChild(div);
            }
        }

        async function requestPDF() {
            const btn = document.getElementById('btn-pdf');
            btn.disabled = true;
            const originalText = btn.innerText;
            btn.innerText = "Erstelle PDF... (Bitte warten)";

            // Sammelt alle AKTIVEN Checkboxen aus der Sidebar
            const checkboxes = document.querySelectorAll('.layer-checkbox:checked');
            const activeLayers = Array.from(checkboxes).map(cb => cb.value);

            // Werte für Maßstab und Einheit holen
            const unitMultiplier = parseFloat(document.getElementById('dxf-unit').value);
            const scaleDenominator = parseFloat(document.getElementById('pdf-scale').value);

            try {
                const response = await fetch('generate_pdf', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        dxf_file: currentDxfFile,
                        original_name: currentOriginalName,
                        layers: activeLayers,
                        unit: unitMultiplier,
                        scale: scaleDenominator
                    })
                });

                if (response.ok) {
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;

                    // Hole Dateiname aus Response Header, falls vorhanden
                    const contentDisposition = response.headers.get('Content-Disposition');
                    let downloadName = currentOriginalName.replace('.dxf', '.pdf'); // Fallback
                    if (contentDisposition && contentDisposition.includes('filename=')) {
                        const match = contentDisposition.match(/filename="?([^"]+)"?/);
                        if (match) downloadName = match[1];
                    }

                    a.download = downloadName;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    showToast("PDF erfolgreich heruntergeladen!", "success");
                } else {
                    let errorMsg = response.statusText;
                    try { const errData = await response.json(); errorMsg = errData.error || errorMsg; } catch (e) { }
                    showToast("Fehler bei der PDF-Erstellung: " + errorMsg);
                }
            } catch (e) {
                showToast("Netzwerkfehler oder Server nicht erreichbar.");
            } finally {
                btn.innerText = originalText;
                btn.disabled = false;
            }
        }

        function downloadDXF() {
            if (!currentDxfFile) return;
            const a = document.createElement('a');
            a.href = 'dxf/' + currentDxfFile;

            // Generate a good download name
            let downloadName = currentOriginalName;
            if (downloadName.toLowerCase().endsWith('.dwg')) {
                downloadName = downloadName.substring(0, downloadName.length - 4) + '.dxf';
            }
            a.download = downloadName;

            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }
    </script>
</body>

</html>